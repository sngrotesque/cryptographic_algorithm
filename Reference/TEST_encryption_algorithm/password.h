// 作者: SN-Grotesque
// 用于加密密钥的密钥以下简称为副秘钥
//
//
//

#include "base_include.h"

#define KEY_BITS_N    4096    // 主密钥的位长
#define KEY_BYTES_N   256     // 主密钥字节长度
#define KEY_MIN_VALUE 0x1000  // 主密钥最小值
#define KEY_MAX_VALUE 0xFFFF  // 主密钥最大值
#define ENCRYPT_KEY_KEY_BITS_N    2048 // 副秘钥位长
#define ENCRYPT_KEY_KEY_BYTES_N   256  // 副秘钥字节长度
#define ENCRYPT_KEY_KEY_MIN_VALUE 0x00 // 副秘钥最小值
#define ENCRYPT_KEY_KEY_MAX_VALUE 0xFF // 副秘钥最大值

#define P2C(p, k1, k2)      (((p << 4) ^ k1) << 4) ^ k2
#define P2C_XOR(p, k, mov)  (p ^ k) - mov

typedef struct {
    uint8_t *p;           // 明文
    uint64_t p_n;         // 明文长度
    uint8_t *c;           // 密文
    uint64_t c_n;         // 密文长度
    uint16_t *main_key;   // 主密钥
    uint8_t  mov[4];      // 偏移量
} sn_pwd;

// 主密钥，其实不应该直接像这样展示出来的
const uint32_t main_key[256] = {
    0x983C, 0xC31E, 0xBD1E, 0xD338, 0xD069, 0x8099, 0x689B, 0x93C2, 0x5B38, 0x5CAA, 0x59C7, 0x80FF, 0x4E67, 0x3B56, 0xBF50, 0xCDDA, 
    0xE6DB, 0x5C28, 0x123A, 0xDF81, 0x4222, 0x9BB2, 0x33AB, 0xD915, 0xB07B, 0x458A, 0x6E33, 0x4689, 0xA3E2, 0xBD01, 0xD1BA, 0xE943, 
    0x9477, 0xDD77, 0x1B1D, 0xDE8A, 0x2685, 0xF589, 0xC6B2, 0xCADF, 0x4C2B, 0x30FD, 0x7D4D, 0xDC78, 0x76F8, 0x3CE4, 0x1562, 0x1061, 
    0xCDB4, 0x89AD, 0x364F, 0x99AB, 0x7F5D, 0xDD44, 0xDD2F, 0x46B8, 0xAC58, 0xBBDC, 0xFC51, 0x4A8A, 0x4155, 0x6BDA, 0x8F41, 0xF719, 
    0xC88D, 0xD8AB, 0x2E0E, 0xFDF5, 0x6D38, 0xA266, 0xFCDA, 0x7549, 0xF711, 0x1A9B, 0x622B, 0x779F, 0xC8C1, 0x1C7E, 0x6AC6, 0x763D, 
    0x6C13, 0x5FFA, 0x2B4F, 0xB86D, 0xF6A3, 0x5769, 0x455C, 0xF4B5, 0xEE84, 0x9423, 0xA86F, 0xDBE4, 0xF5EA, 0xF6F1, 0x3C49, 0x40BA, 
    0x1B81, 0x5964, 0x6056, 0xE9D0, 0x4DAD, 0x6771, 0x297D, 0x81D3, 0x97EC, 0xF394, 0x50DF, 0x3C5A, 0x978E, 0xE80F, 0xDB0D, 0xBC41, 
    0xC5AD, 0x7F3F, 0x1F42, 0xF8AF, 0xCA7F, 0xC310, 0x547F, 0x35FD, 0x54AC, 0xF0C3, 0x9DBE, 0x93AA, 0xC8FA, 0x3265, 0xE172, 0x9FCE, 
    0x2DCE, 0x222D, 0xBAD0, 0xF5AC, 0x7766, 0x41CE, 0xC464, 0xBFD4, 0x562E, 0x8084, 0x90AA, 0x2845, 0x86AE, 0x6F2C, 0x23C4, 0x275D, 
    0x3D8E, 0x8D15, 0x8998, 0xBCDC, 0x7D96, 0xE555, 0xE5ED, 0x770A, 0xE4D2, 0x4560, 0xAD72, 0xFE7D, 0xD606, 0xCD5D, 0x70DB, 0x3EC2, 
    0x6981, 0xEFBE, 0x8202, 0xB024, 0xFE8A, 0x64C5, 0x4B1E, 0x6AF2, 0xB646, 0xA1D0, 0x2BCA, 0x6C8A, 0x4A26, 0x4C24, 0x666C, 0xD46B, 
    0x9540, 0x8662, 0x63CC, 0xB4B6, 0xF33B, 0x6FAA, 0x2CDA, 0xEAD1, 0x90B5, 0x1B02, 0x5F11, 0x6B24, 0x9629, 0xCE08, 0x24AF, 0xF2F5, 
    0x790A, 0x6615, 0xEBB7, 0xD502, 0x2466, 0x732A, 0x43A0, 0xD9DF, 0x2669, 0xDD7C, 0x2C68, 0xF64C, 0xB237, 0xD86E, 0xADE7, 0x6C32, 
    0xDEE7, 0x604F, 0x4114, 0xB778, 0xD2E7, 0x9C0F, 0xB0D9, 0xE14C, 0xFB0E, 0x62BB, 0xCCA8, 0xC74B, 0x3089, 0x135E, 0xFB98, 0x75E2, 
    0xE4E2, 0xEC5B, 0x7582, 0xD610, 0x7B0C, 0xB31F, 0x6D5C, 0xAA66, 0x374E, 0xD790, 0xC45E, 0x755D, 0xB379, 0xB02B, 0xBA62, 0x7AA1, 
    0x1B00, 0x3AC3, 0xD06B, 0xB91D, 0x1863, 0x7EF3, 0xF605, 0x5ED5, 0x3DB6, 0x8814, 0x8F57, 0xA99E, 0xBE38, 0xD35D, 0x910F, 0x4C12
};

// 副秘钥，用于加密主密钥，同时也用于加密明文
const uint8_t encrypt_key_key[256] = {
    0xDD, 0x67, 0x8C, 0x20, 0xF7, 0x90, 0x88, 0xAB, 0xC3, 0xBC, 0x47, 0x6C, 0x5E, 0xF4, 0xA7, 0xD3,
    0xFC, 0x2F, 0x9F, 0x67, 0xA7, 0x9E, 0x83, 0xC5, 0x30, 0x63, 0x6E, 0x1F, 0x37, 0x9C, 0xA3, 0xC8,
    0x3F, 0xCB, 0xF9, 0x95, 0x12, 0x5C, 0x68, 0x8E, 0x92, 0x3F, 0xF0, 0x32, 0xC3, 0x30, 0xB8, 0x4B,
    0xF4, 0x46, 0x77, 0xAA, 0x14, 0xD0, 0x5A, 0x0C, 0x89, 0x9C, 0x1C, 0x3A, 0x9B, 0x85, 0x87, 0x07,
    0x26, 0x48, 0xD9, 0x54, 0xFA, 0x00, 0xF0, 0x4E, 0x9A, 0xDA, 0xD1, 0x44, 0x8E, 0xBD, 0x83, 0x62,
    0xFF, 0xA4, 0x0C, 0x8F, 0x04, 0x5F, 0x79, 0xD4, 0x2C, 0xB0, 0x6E, 0x6B, 0x90, 0x57, 0x92, 0x92,
    0x99, 0x02, 0x5B, 0x1E, 0x4A, 0xDB, 0xFC, 0x57, 0xC5, 0xF4, 0x88, 0x32, 0x86, 0x13, 0x8E, 0x06,
    0x37, 0x22, 0x8F, 0xF0, 0xE3, 0x3E, 0x3F, 0x2F, 0xE4, 0x1E, 0xB9, 0x98, 0xBC, 0xC2, 0xC4, 0xF0,
    0xDB, 0x5C, 0x27, 0xCA, 0x0D, 0x6D, 0x67, 0x59, 0x4B, 0xCF, 0x08, 0x5D, 0x3B, 0x1A, 0x0F, 0xE7,
    0xEE, 0xC6, 0x1D, 0xE3, 0x7C, 0xA2, 0xCF, 0x98, 0x6A, 0x3D, 0x38, 0x02, 0x50, 0x8F, 0x44, 0xFC,
    0xEF, 0x8B, 0xCD, 0xE0, 0x00, 0xCA, 0x86, 0xE0, 0xAA, 0xA7, 0xC2, 0x09, 0xEB, 0xDF, 0xBD, 0x66,
    0xF7, 0xD9, 0xDB, 0xDE, 0xBC, 0x17, 0xF1, 0x2C, 0x65, 0xF9, 0xB2, 0xAC, 0x67, 0x8E, 0xFB, 0xE0,
    0xAF, 0x4B, 0xA6, 0x31, 0xCD, 0x86, 0x6E, 0xA1, 0x48, 0x11, 0xD2, 0x1E, 0x25, 0xB1, 0x95, 0x71,
    0x29, 0x36, 0x42, 0x3E, 0xD4, 0xDC, 0xD0, 0x5C, 0x4B, 0xC9, 0x35, 0x4E, 0xE9, 0x2F, 0x71, 0xDE,
    0x38, 0xD2, 0xC6, 0x23, 0xBD, 0xBC, 0x36, 0xC9, 0xF2, 0x2C, 0xA9, 0x3F, 0x4F, 0xD8, 0xCC, 0x36,
    0x57, 0x5E, 0xDE, 0x29, 0x77, 0x75, 0xD2, 0xF6, 0x27, 0xE6, 0xF2, 0xD8, 0xB0, 0xAC, 0x52, 0x7B
};

static uint8_t *key_encrypt(const uint16_t *key)
{
    char temp[5];
    uint32_t x, y;
    uint8_t *p_tmp = (uint8_t *)malloc(2);
    uint8_t *ptr = (uint8_t *)malloc(KEY_BYTES_N * 2);
    uint8_t index;
    for(x = y = index = 0; x < KEY_BYTES_N; ++x, y+=2, index+=2) {
        memset(temp, 0, 5);
        sprintf(temp, "%04X", key[x]);
        p_tmp = htos(temp);
        ptr[y]   = p_tmp[0] ^ encrypt_key_key[index];
        ptr[y+1] = p_tmp[1] ^ encrypt_key_key[index+1];
    }
    ptr = b64en(ptr, KEY_BYTES_N * 2);
    return ptr;
};

static uint16_t *key_decrypt(uint8_t *key_c)
{
    uint8_t *k_b64;
    uint8_t index;
    uint32_t x, y;
    char t1[3], t2[5];
    char temp[1025] = {0};
    k_b64 = b64de(key_c);
    uint16_t *key = (uint16_t *)malloc(512);
    char *ptr;
    for(x = y = index = 0; x < 512; ++x, ++index, y+=2) {
        sprintf(t1, "%02X", k_b64[x] ^ encrypt_key_key[index]);
        temp[y] = t1[0], temp[y+1] = t1[1];
    }
    for(x = y = 0; x < 256; x++, y+=4) {
        memset(t2, 0, 5);
        t2[0] = temp[y],   t2[1] = temp[y+1];
        t2[2] = temp[y+2], t2[3] = temp[y+3];
        key[x] = strtol(t2, &ptr, 16);
    }
    return key;
}

static int key_w(uint8_t *key_data, const char *filePath)
{
    if (key_data == NULL) {return -1;}
    FILE *p = fopen(filePath, "wb");
    if (!p) {return -1;}
    while(key_data[0] != 0) {
        fputc(key_data[0], p);
        key_data++;
    }
    fclose(p);
    return 0;
}

static uint8_t *key_r(const char *filePath)
{
    FILE *p = fopen(filePath, "rb");
    if (!p) {return NULL;}
    long filesize = get_file_size(p);
    char temp;
    uint8_t *keyData = (uint8_t *)calloc(filesize+1, 1);
    uint8_t *keyPtr = keyData;
    while((temp = fgetc(p)) != EOF) {
        keyData[0] = (uint8_t)temp;
        keyData++;
    }
    fclose(p);
    return keyPtr;
}

static int passwd_encrypt(sn_pwd *data)
{
    if (data->p_n == 0 || data->p == NULL) {return -1;}
    data->c_n = data->p_n * 4;
    data->c = (uint8_t *)calloc(data->c_n, 1);
    char temp[5];

    uint32_t x, y;
    uint8_t  index;
    for(x = y = index = 0; x < data->p_n; x++, y+=4, index++) {
        memset(temp, 0, 5);
        sprintf(temp, "%04X", P2C(data->p[x], encrypt_key_key[index], data->main_key[index]));
        data->c[y]   = P2C_XOR(temp[0], encrypt_key_key[index], data->mov[0]);
        data->c[y+1] = P2C_XOR(temp[1], encrypt_key_key[index], data->mov[1]);
        data->c[y+2] = P2C_XOR(temp[2], encrypt_key_key[index], data->mov[2]);
        data->c[y+3] = P2C_XOR(temp[3], encrypt_key_key[index], data->mov[3]);
    }
    data->c = b64en(data->c, data->c_n);
    return 0;
}

static int passwd_decrypt(sn_pwd *data)
{
    return 0;
}




