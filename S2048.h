#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

#ifndef __SN_OBJECT__
#define __SN_OBJECT__ 1

#define PADDING_DATA_N   256    // 256 Bytes
#define PADDING_KEY_N    256    // 256 Bytes
#define PADDING_DATA     179    // 填充值 0xb3
#define NUMBER_OF_ROUNDS 14     // 加密解密轮数

typedef struct {
    u8 *data;  // 数据
    u8 *token;   // 密码
    u64 len;   // 数据长度
} sn;

// 初始混淆值 (可自定义)
const static u8 sbox[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif

#ifndef __BASE64_H__
#define __BASE64_H__ 1

// 计算Base64编码后的数据长度
static u64 b64en_n(u64 _n)
{
    switch(_n % 3) {
        case 0:
            _n = _n / 3 * 4; break;
        default:
            _n = (_n / 3 + 1) * 4; break;
    } return _n;
}

// 计算Base64解码码后的数据长度
static u64 b64de_n(char *data)
{
    u64 len = strlen(data), _n;
    if (strstr(data, "==")) {
        _n = len / 4 * 3 - 2;
    } else if (strstr(data, "=")) {
        _n = len / 4 * 3 - 1;
    } else {
        _n = len / 4 * 3;
    } return _n;
}

static u8 *b64en(u8 *data, u64 _n)
{
    const char *B64_T = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    u64 len = b64en_n(_n), i, j;
    u8 *res = (u8 *)malloc(len + 1);
    res[len] = 0x00;

    for (i = 0, j = 0; i < len - 2; j += 3, i += 4) {
        res[i]   = B64_T[data[j]>>2];
        res[i+1] = B64_T[(data[j] & 0x3)   << 4 | (data[j+1] >> 4)];
        res[i+2] = B64_T[(data[j+1] & 0xf) << 2 | (data[j+2] >> 6)];
        res[i+3] = B64_T[data[j+2] & 0x3f];
    }
    
    switch (_n % 3) {
        case 1:
            res[i - 2] = '=';
            res[i - 1] = '=';
            break;
        case 2:
            res[i - 1] = '=';
            break;
    }
    return res;
}

static u8 *b64de(u8 *code)
{
    u32 table[123] = {
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
        0,  62, 0,  0,  0,  63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,  0,  0,  0,  0,
        0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18,
        19, 20, 21, 22, 23, 24, 25, 0,  0,  0,  0,  0,  0,  26, 27, 28, 29, 30, 31, 32, 33,
        34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};
    u64 s_len = strlen((char *)code), len = b64de_n((char *)code), i, j;
    u8 *res = (u8 *)malloc(len + 1);
    res[len] = 0x00;
    
    for (i = 0, j = 0; i < s_len - 2; j += 3, i += 4) {
        res[j]   = ((u8)table[code[i]])    << 2  | (((u8)table[code[i+1]]) >> 4);
        res[j+1] = (((u8)table[code[i+1]]) << 4) | (((u8)table[code[i+2]]) >> 2);
        res[j+2] = (((u8)table[code[i+2]]) << 6) | ((u8)table[code[i+3]]);
    }
    return res;
}
#endif

#ifndef __SN_FUNCTION__
#define __SN_FUNCTION__ 1

static void PKCS7_Padding(u8 *InOutBuf, u64 *Inoutlen, u16 Blocksize)  
{
	u8 paddata = 0x00;
	u64 padoffset = 0x00;
	u64 lp = *Inoutlen;
	paddata = Blocksize - (lp % Blocksize);
	padoffset = ( lp / Blocksize) * Blocksize + (lp % Blocksize);
	for(u64 i = 0; i < paddata; i++) {
        InOutBuf[padoffset + i] = paddata;
        *Inoutlen += paddata;
    }
}

// 密钥生成函数
static u8 **Round_key_obfuscation(u8 *key, u8 n, )
{
    return NULL;
}

// 加密函数
static int SN2048_ENCRYPT(sn *data)
{
    return 0;
}

// 解密函数
static int SN2048_DECRYPT(sn *data)
{
    return 0;
}
#endif


